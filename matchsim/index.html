<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Match Simulator</title>

  <link rel="apple-touch-icon" sizes="180x180" href="https://metrobots.github.io/assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://metrobots.github.io/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://metrobots.github.io/assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="https://metrobots.github.io/assets/favicon/site.webmanifest">
  <link rel="mask-icon" href="https://metrobots.github.io/assets/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#333333">
  <meta name="theme-color" content="#ffffff">

  <style>
    body {
      font-family: "Poppins", sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }

    .container {
      max-width: 400px;
      margin: 50px auto;
      text-align: center;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    input[type="text"] {
      padding: 10px;
      margin: 10px 0;
      width: calc(100% - 20px);
      border: 1px solid #ccc;
      border-radius: 5px;
      box-sizing: border-box;
    }

    button {
      padding: 10px 20px;
      background-color: black;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s;
    }

    .dark-mode .button {
      background-color: white;
    }

    #team-data {
      margin-top: 20px;
      text-align: center;
    }

    .statistic-container {
      background-color: #f0f0f0;
      padding: 10px;
      border-radius: 10px;
      margin-top: 10px;
      display: none;
    }

    .combined-scores {
      background-color: #f0f0f0;
      padding: 10px;
      border-radius: 10px;
      margin-top: 10px;
      display: inline-block;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 8px;
      border-bottom: 1px solid #ddd;
      text-align: left;
    }

    th {
      background-color: #007bff;
      color: white;
    }

    .total-score {
      font-weight: bold;
      color: #007bff;
    }

    @keyframes drawCircle {
      0% {
        stroke-dasharray: 0 251.2;
      }

      100% {
        stroke-dasharray: 251.2 0;
      }
    }

    .circle {
      fill: none;
      stroke-width: 30;
      stroke-dasharray: 0 251.2;
      stroke-dashoffset: 0;
      border-radius: 50%;
      cursor: pointer;
    }

    .circle {
      fill: none;
      stroke-width: 30;
      stroke-dasharray: 0 251.2;
      stroke-dashoffset: 0;
      border-radius: 50%;
      cursor: pointer;
      position: relative;
      z-index: 1;
    }

    .score-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(0%, 0%);
      font-size: 24px;
      fill: gray;
      cursor: pointer;
    }

    .red {
      color: red;
    }

    .dark-mode body {
      background-color: #000 !important;
      color: #fff !important;
    }

    .blue {
      color: blue;
    }

    .black {
      color: black;
    }

    .light-mode .score-text {
      fill: black;
      o
    }

    .dark-mode .score-text {
      fill: white !important;
    }

    .dark-mode-toggle {
      position: absolute !important;
      top: 10px !important;
      left: 10px !important;
      width: 20px !important;
      height: 20px !important;
      background-color: #ccc !important;
      border-radius: 50% !important;
      cursor: pointer !important;
      transition: transform 0.5s, background-color 0.5s !important;
    }

    .dark-mode-toggle::after {
      content: "" !important;
      display: block !important;
      width: 10px !important;
      height: 10px !important;
      border-radius: 50% !important;
      background-color: #000 !important;
      position: relative !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      transition: transform 0.5s, background-color 0.5s !important;
    }

    .dark-mode .dark-mode-toggle {
      background-color: #333 !important;
      transform: rotate(180deg) scale(1.2) !important;
    }

    .dark-mode .dark-mode-toggle::after {
      background-color: #fff !important;
      transform: rotate(180deg) scale(1.2) !important;
    }

    .dark-mode .container {
      background-color: #333 !important;
      color: #fff !important;
    }

    .dark-mode input[type="text"] {
      background-color: #444 !important;
      color: #fff !important;
      border-color: #666 !important;
    }

    .dark-mode .dark-mode-toggle {
      background-color: #ccc !important;
    }

    .dark-mode .team-data {
      fill: white !important;
    }

    .dark-mode .dark-mode-toggle::after {
      background-color: #000 !important;
    }

    .dark-mode .statistic-container {
      background-color: #444 !important;
      color: #fff !important;
      border-color: #666 !important;
    }

    .green-mode .team-data {
      fill: green;
    }

    .dark-mode-toggle {
      position: absolutev;
      top: 10px !important;
      left: 10px !important;
      width: 20px !important;
      height: 20px !important;
      background-color: #ccc !important;
      border-radius: 50% !important;
      cursor: pointer !important;
    }

    .dark-mode-toggle::after {
      content: "" !important;
      display: block !important;
      width: 10px !important;
      height: 10px !important;
      border-radius: 50% !important;
      background-color: #000 !important;
      position: relative !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
    }

    .dark-mode .dark-mode-toggle {
      background-color: #333 !important;
    }

    .dark-mode .dark-mode-toggle::after {
      background-color: #fff !important;
    }

    .taClass {
      color: black;
    }

    .atClass {
      color: black;
    }

    .tatClass {
      color: black;
    }

    .docs-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background-color: black;
      color: #fff;
      padding: 10px 20px;
      border-radius: 5px;
      text-decoration: none;
    }

    .docs-button:hover {
      background-color: dimgray;
    }

    .dark-mode .button {
      background-color: white;
    }
  </style>
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

  <div class="container">
    <h2 class="taClass">Match Sim</h2>
    <input type="text" id="teamNumbers" placeholder="####...">
    <datalist id="suggestions"></datalist>
    <button onclick="handleTeamInput()">Search</button>
    <div class="dark-mode-toggle" onclick="toggleDarkMode()"></div>
    <a href="https://metrobots.github.io/docs/" class="docs-button">Docs</a>
    <div id="team-data"></div>
  </div>
  <script src="https://metrobots.github.io/matchsim/teams.js"></script>
  <script>
    async function handleTeamInput() {
      stopSuggestionCycle();
      const inputField = document.getElementById('teamNumbers');
      const input = inputField.value.trim();
      if (input.includes('-')) {
        console.log("dashed");
        const [redAlliance, blueAlliance] = input.split('-').map(str => str.trim());
        const redTeams = redAlliance.split(',').map(num => num.trim()).filter(num => num);
        const blueTeams = blueAlliance.split(',').map(num => num.trim()).filter(num => num);
        if (redTeams.length === 3 && blueTeams.length === 3) {
          const teamNumbers = [...redTeams, ...blueTeams];
          await handleMatchSimulation(teamNumbers);
          return;
        }
      }
      const inputParts = input.split(',').map(part => part.trim()).filter(part => part);
      const teamNumbers = [];
      for (let item of inputParts) {
        if (!isNaN(item) && item) {
          teamNumbers.push(item);
        } else {
          const team = teams.find(team => team.teamName.toLowerCase() === item.toLowerCase());
          if (team) {
            teamNumbers.push(team.teamNumber);
          } else {
            if (inputParts.length === 1) {
              const suggestions = getTeamNameSuggestions(item);
              if (suggestions.length > 0) {
                console.warn(`No exact team name found for: "${item}". Suggestions: ${suggestions.join(', ')}`);
                startSuggestionCycle(inputField, suggestions);
                return;
              } else {
                console.warn(`No team number found or suggestions for name: "${item}"`);
              }
            }
          }
        }
      }
      if (teamNumbers.length === 1) {
        await handleSingleTeam(teamNumbers[0]);
      } else if (teamNumbers.length === 3) {
        await handleAllianceData(teamNumbers);
      } else if (teamNumbers.length !== 6) {
        document.getElementById('team-data').innerHTML =
          '<p style="color: red;">Please enter either:<br>' +
          '- Single team number or name<br>' +
          '- Three team numbers separated by commas (alliance)<br>' +
          '- Six team numbers separated by commas and a dash (match simulation)<br>' +
          'Example match simulation: 254,1678,1323-148,118,971</p>';
      }
    }
    async function handleSingleTeam(teamNumber) {
      try {
        const response = await fetch(`https://api.statbotics.io/v3/team_year/${teamNumber}/${new Date().getFullYear()}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const teamData = await response.json();
        const performance = calculateTeamPerformance(teamData);
        displaySingleTeamData(teamData, performance);
        const searchID = generateSearchID([teamNumber]);
        window.history.replaceState({}, '', `?search=${searchID}`);
      } catch (error) {
        console.error('Error fetching single team data:', error);
        document.getElementById('team-data').innerHTML =
          `<p style="color: red;">Error loading data for team ${teamNumber}. Please try again.</p>`;
      }
    }
    async function handleAllianceData(teamNumbers) {
      try {
        const teamDataArray = await Promise.all(
          teamNumbers.map(teamNumber =>
            fetch(`https://api.statbotics.io/v3/team_year/${teamNumber}/${new Date().getFullYear()}`)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return response.json();
            })
          )
        );
        const aggregatedData = aggregateTeamData(teamDataArray);
        displayAggregatedData(aggregatedData, teamDataArray);
      } catch (error) {
        console.error('Error fetching alliance data:', error);
        document.getElementById('team-data').innerHTML =
          '<p style="color: red;">Error loading alliance data. Please try again.</p>';
      }
    }
    async function handleMatchSimulation(teamNumbers) {
      try {
        const teamDataArray = await Promise.all(
          teamNumbers.map(teamNumber =>
            fetch(`https://api.statbotics.io/v3/team_year/${teamNumber}/${new Date().getFullYear()}`)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return response.json();
            })
          )
        );
        const redAlliance = teamDataArray.slice(0, 3);
        const blueAlliance = teamDataArray.slice(3, 6);
        const redScores = calculateAllianceScores(redAlliance);
        const blueScores = calculateAllianceScores(blueAlliance);
        displayMatchSimulation(redScores, blueScores, redAlliance, blueAlliance);
      } catch (error) {
        console.error('Error fetching match simulation data:', error);
        document.getElementById('team-data').innerHTML =
          '<p style="color: red;">Error loading match simulation data. Please try again.</p>';
      }
    }

    function startSuggestionCycle(inputField, suggestions) {
      stopSuggestionCycle();
      suggestionIndex = 0;
      cyclingSuggestions = setInterval(() => {
        inputField.value = suggestions[suggestionIndex];
        suggestionIndex = (suggestionIndex + 1) % suggestions.length;
      }, 1000);
    }

    function stopSuggestionCycle() {
      if (cyclingSuggestions) {
        clearInterval(cyclingSuggestions);
        cyclingSuggestions = null;
      }
    }
    document.addEventListener('DOMContentLoaded', () => {
      const teamNumbersInput = document.getElementById('teamNumbers');
      teamNumbersInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleTeamInput();
        }
      });
      teamNumbersInput.addEventListener('input', () => {
        stopSuggestionCycle();
      });
      const searchButton = document.getElementById('searchButton');
      if (searchButton) {
        searchButton.addEventListener('click', handleTeamInput);
      }
      loadSearchFromURL();
    });
    let suggestionIndex = 0;
    let cyclingSuggestions = null;

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function startSuggestionCycle(inputField, suggestions) {
      stopSuggestionCycle();
      suggestionIndex = 0;
      cyclingSuggestions = setInterval(() => {
        inputField.value = suggestions[suggestionIndex];
        suggestionIndex = (suggestionIndex + 1) % suggestions.length;
      }, 1000);
    }

    function stopSuggestionCycle() {
      if (cyclingSuggestions) {
        clearInterval(cyclingSuggestions);
        cyclingSuggestions = null;
      }
    }

    function getLevenshteinDistance(a, b) {
      const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(null));
      for (let i = 0; i <= a.length; i++) {
        matrix[i][0] = i;
      }
      for (let j = 0; j <= b.length; j++) {
        matrix[0][j] = j;
      }
      for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
          const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1,
            matrix[i - 1][j - 1] + indicator
          );
        }
      }
      return matrix[a.length][b.length];
    }

    function getTeamNameSuggestions(inputName) {
      const maxDistance = 3;
      const keyword = inputName.toLowerCase();
      const suggestions = teams
        .map(team => ({
          teamName: team.teamName,
          distance: getLevenshteinDistance(team.teamName.toLowerCase(), inputName.toLowerCase())
        }))
        .filter(item => item.distance <= maxDistance || item.teamName.toLowerCase().includes(keyword))
        .sort((a, b) => {
          const aHasKeyword = a.teamName.toLowerCase().includes(keyword);
          const bHasKeyword = b.teamName.toLowerCase().includes(keyword);
          if (aHasKeyword && !bHasKeyword) return -1;
          if (!aHasKeyword && bHasKeyword) return 1;
          return a.distance - b.distance;
        })
        .slice(0, 5)
        .map(item => item.teamName);
      return suggestions;
    }

    function generateSearchID(teamNumbers) {
      return btoa(teamNumbers.join(','));
    }

    function loadSearchFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const searchID = urlParams.get('search');
      if (searchID) {
        const teamNumbers = atob(searchID).split(',');
        document.getElementById('teamNumbers').value = teamNumbers.join(', ');
        handleTeamInput();
      }
    }
    window.onload = loadSearchFromURL;
    document.getElementById('teamNumbers').addEventListener('input', () => {
      stopSuggestionCycle();
    });

    function calculateTeamPerformance(data) {
      const maximumPossibleMatchScore = 130;
      const maxAutoPoints = 30;
      const maxTeleopPoints = 80;
      const maxEndgamePoints = 20;
      const normalizedScores = {
        totalEPA: data.epa.total_points.mean / maximumPossibleMatchScore,
        unitlessEPA: data.epa.unitless / 3000,
        normalizedEPA: data.epa.norm / 3000,
        globalPercentile: data.epa.ranks.total.percentile,
        countryPercentile: data.epa.ranks.country.percentile,
        statePercentile: data.epa.ranks.state.percentile,
        gamePieceEfficiency: data.epa.breakdown.total_game_pieces / 15,
        autoEfficiency: data.epa.breakdown.auto_points / maxAutoPoints,
        teleopEfficiency: data.epa.breakdown.teleop_points / maxTeleopPoints,
        endgameEfficiency: data.epa.breakdown.endgame_points / maxEndgamePoints,
        autoRP: data.epa.breakdown.auto_rp,
        coralRP: data.epa.breakdown.coral_rp,
        bargeRP: data.epa.breakdown.barge_rp,
        coralEfficiency: (data.epa.breakdown.auto_coral_points + data.epa.breakdown.teleop_coral_points) /
          (maxAutoPoints + maxTeleopPoints),
        processorEfficiency: (data.epa.breakdown.auto_processor + data.epa.breakdown.teleop_processor) / 2,
        algaeEfficiency: (data.epa.breakdown.auto_algae + data.epa.breakdown.teleop_algae) / 2
      };
      const weights = {
        totalEPA: 0.15,
        unitlessEPA: 0.1,
        normalizedEPA: 0.1,
        globalPercentile: 0.1,
        countryPercentile: 0.05,
        statePercentile: 0.05,
        gamePieceEfficiency: 0.1,
        autoEfficiency: 0.05,
        teleopEfficiency: 0.1,
        endgameEfficiency: 0.05,
        autoRP: 0.025,
        coralRP: 0.025,
        bargeRP: 0.025,
        coralEfficiency: 0.05,
        processorEfficiency: 0.025,
        algaeEfficiency: 0.025
      };
      let compositeScore = 0;
      for (const [metric, value] of Object.entries(normalizedScores)) {
        compositeScore += value * weights[metric];
      }
      const consistencyFactor = 1 - (data.epa.total_points.sd / data.epa.total_points.mean) * 0.1;
      compositeScore *= consistencyFactor;
      return Math.max(0, Math.min(1, compositeScore));
    }

    function aggregateTeamData(teamDataArray) {
      const totalEPA = teamDataArray.reduce((sum, data) => sum + data.epa.total_points.mean, 0);
      const totalSD = Math.sqrt(
        teamDataArray.reduce((sum, data) => sum + Math.pow(data.epa.total_points.sd, 2), 0)
      );
      const autoPoints = teamDataArray.reduce((sum, data) => sum + data.epa.breakdown.auto_points, 0);
      const teleopPoints = teamDataArray.reduce((sum, data) => sum + data.epa.breakdown.teleop_points, 0);
      const endgamePoints = teamDataArray.reduce((sum, data) => sum + data.epa.breakdown.endgame_points, 0);
      const avgPercentile = teamDataArray.reduce((sum, data) =>
        sum + data.epa.ranks.total.percentile, 0) / teamDataArray.length;
      return {
        compositeScore: avgPercentile,
        totalEPA,
        totalSD,
        autoPoints,
        teleopPoints,
        endgamePoints
      };
    }

    function displaySingleTeamData(data, performance) {
      var teamData = document.getElementById('team-data');
      const totalGamePieces = data.epa.breakdown.total_game_pieces;
      const avgPointsPerPiece = data.epa.total_points.mean / totalGamePieces;
      teamData.innerHTML = `
    <h2 class="atClass">${data.name} (${data.year})</h2>
    <svg width="200" height="200" onclick="toggleTeamData()">
      <circle class="circle" cx="100" cy="100" r="80"></circle>
      <text x="100" y="100" dominant-baseline="middle" text-anchor="middle" class="score-text">${performance.toFixed(2)}</text>
    </svg>

    <div class="statistic-container">
      <h3 onclick="toggleSection(this)">Team Information</h3>
      <div class="section-content">
        <p>Team Number: ${data.team}</p>
        <p>Location: ${data.state}, ${data.country}</p>
        ${data.district ? `<p>District: ${data.district}</p>` : ''}
      </div>
      
      <h3 onclick="toggleSection(this)">Comp Status</h3>
      <div class="section-content">
        ${data.competing.this_week ? 
          '<p>Competing this week</p>' : 
          (data.competing.next_event_key ? 
            `<p>Next Event: ${data.competing.next_event_name} (Week ${data.competing.next_event_week})</p>` : 
            '<p>No upcoming events scheduled</p>')}
        
        ${data.record.count > 0 ? `
          <p>Match Record: ${data.record.wins}-${data.record.losses}-${data.record.ties} 
             (Win Rate: ${(data.record.winrate * 100).toFixed(1)}%)</p>
        ` : ''}
        
        ${data.district_points !== null ? `
          <p>District Points: ${data.district_points}</p>
          <p>District Rank: ${data.district_rank}</p>
        ` : ''}
      </div>
      
      <h3 onclick="toggleSection(this)">Performance Metrics</h3>
      <div class="section-content">
        <p>EPA Rating: <b>${data.epa.total_points.mean.toFixed(2)}</b> Â± ${data.epa.total_points.sd.toFixed(2)}</p>
        <p>Unitless EPA: <b>${data.epa.unitless}</b></p>
        <p>Normalized EPA: <b>${data.epa.norm.toFixed(2)}</b></p>
        
        <p>Global Rank: <b>${data.epa.ranks.total.rank}</b> / ${data.epa.ranks.total.team_count} 
           (Top ${(data.epa.ranks.total.percentile * 100).toFixed(1)}%)</p>
        <p>State Rank: <b>${data.epa.ranks.state.rank}</b> / ${data.epa.ranks.state.team_count}
           (Top ${(data.epa.ranks.state.percentile * 100).toFixed(1)}%)</p>
        
        ${data.epa.ranks.district ? `
          <p>District Rank: <b>${data.epa.ranks.district.rank}</b> / ${data.epa.ranks.district.team_count}
             (Top ${(data.epa.ranks.district.percentile * 100).toFixed(1)}%)</p>
        ` : ''}
      </div>
      
      <h3 onclick="toggleSection(this)">Game Piece Analysis</h3>
      <div class="section-content">
        <p>Average Game Pieces per Match: <b>${data.epa.breakdown.total_game_pieces.toFixed(2)}</b></p>
        <p>Points per Game Piece: <b>${avgPointsPerPiece.toFixed(2)}</b></p>
        
        <h4>Game Piece Breakdown</h4>
        <ul>
          <li>Coral: ${data.epa.breakdown.total_coral_points.toFixed(2)} points 
            (L1: ${data.epa.breakdown.coral_l1.toFixed(2)}, 
             L2: ${data.epa.breakdown.coral_l2.toFixed(2)}, 
             L3: ${data.epa.breakdown.coral_l3.toFixed(2)}, 
             L4: ${data.epa.breakdown.coral_l4.toFixed(2)})</li>
          <li>Processor: ${data.epa.breakdown.total_processor_points.toFixed(2)} points</li>
          <li>Algae: ${data.epa.breakdown.total_algae_points.toFixed(2)} points</li>
        </ul>
      </div>
      
      <h3 onclick="toggleSection(this)">Scoring Breakdown</h3>
      <div class="section-content">
        <p>Total Points: <b>${data.epa.breakdown.total_points.toFixed(2)}</b></p>
        
        <h4>Points by Phase</h4>
        <ul>
          <li>Auto Points: <b>${data.epa.breakdown.auto_points.toFixed(2)}</b>
            <ul>
              <li>Auto Leave: ${data.epa.breakdown.auto_leave_points.toFixed(2)}</li>
              <li>Auto Coral: ${data.epa.breakdown.auto_coral_points.toFixed(2)}</li>
              <li>Auto Processor: ${data.epa.breakdown.auto_processor.toFixed(2)}</li>
              <li>Auto Algae: ${data.epa.breakdown.auto_algae.toFixed(2)}</li>
            </ul>
          </li>
          <li>Teleop Points: <b>${data.epa.breakdown.teleop_points.toFixed(2)}</b>
            <ul>
              <li>Teleop Coral: ${data.epa.breakdown.teleop_coral_points.toFixed(2)}</li>
              <li>Teleop Processor: ${data.epa.breakdown.teleop_processor.toFixed(2)}</li>
              <li>Teleop Algae: ${data.epa.breakdown.teleop_algae.toFixed(2)}</li>
            </ul>
          </li>
          <li>Endgame Points: <b>${data.epa.breakdown.endgame_points.toFixed(2)}</b></li>
          <li>Barge Points: <b>${data.epa.breakdown.barge_points.toFixed(2)}</b></li>
          <li>Tiebreaker Points: <b>${data.epa.breakdown.tiebreaker_points.toFixed(2)}</b></li>
        </ul>
      </div>
      
      <h3 onclick="toggleSection(this)">Ranking Point Analysis</h3>
      <div class="section-content">
        <p>Auto RP Rate: ${(data.epa.breakdown.auto_rp * 100).toFixed(1)}%</p>
        <p>Coral RP Rate: ${(data.epa.breakdown.coral_rp * 100).toFixed(1)}%</p>
        <p>Barge RP Rate: ${(data.epa.breakdown.barge_rp * 100).toFixed(1)}%</p>
        
        <h4>Detailed RP Breakdown</h4>
        <ul>
          <li>RP 1: ${(data.epa.breakdown.rp_1 * 100).toFixed(1)}%</li>
          <li>RP 2: ${(data.epa.breakdown.rp_2 * 100).toFixed(1)}%</li>
          <li>RP 3: ${(data.epa.breakdown.rp_3 * 100).toFixed(1)}%</li>
        </ul>
      </div>
    </div>`;
      const toggleSectionScript = document.createElement('script');
      toggleSectionScript.innerHTML = `
    function toggleSection(header) {
      const allHeaders = document.querySelectorAll('.statistic-container h3');
      allHeaders.forEach(h => {
        h.textContent = h.textContent.replace(' â–²', '').replace(' â–¼', '');
      });

      const sectionContent = header.nextElementSibling;
      const isOpen = sectionContent.style.display === 'block';
      
      const allSections = document.querySelectorAll('.section-content');
      allSections.forEach(section => {
        section.style.display = 'none';
      });
      
      if (!isOpen) {
        sectionContent.style.display = 'block';
        header.textContent += ' â–²';
      } else {
        header.textContent += ' â–¼';
      }
    }
  `;
      document.body.appendChild(toggleSectionScript);
      const style = document.createElement('style');
      style.textContent = `
    .section-content {
      display: none;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    
    .statistic-container h3 {
      cursor: pointer;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
      margin-bottom: 5px;
      user-select: none;
    }
    
    .dark-mode .section-content {
      background-color: #444;
      color: #fff;
    }
    
    .dark-mode .statistic-container h3 {
      background-color: #555;
      color: #fff;
    }
    
    .statistic-container h4 {
      margin-top: 15px;
      margin-bottom: 10px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
    }
  `;
      document.head.appendChild(style);
      animateCircle(performance);
    }

    function displayAggregatedData(aggregatedData, teamDataArray) {
      console.log("aggregate");
      const teamData = document.getElementById('team-data');
      let totalWinRate = 0;
      let totalRank = 0;
      let totalMatchScore = 0;
      let totalTeleopScore = 0;
      let totalAutoScore = 0;
      let totalEndgameScore = 0;
      let sdMatchScore = 0;
      const teamNames = teamDataArray.map(data => {
        totalWinRate += data.record.winrate;
        totalRank += data.epa.ranks.total.rank;
        totalMatchScore += data.epa.total_points.mean;
        sdMatchScore += data.epa.total_points.sd;
        totalAutoScore += data.epa.breakdown.auto_points;
        totalTeleopScore += data.epa.breakdown.teleop_points;
        totalEndgameScore += data.epa.breakdown.endgame_points;
        return data.name;
      }).join(', ');
      const teamCount = teamDataArray.length;
      const averages = {
        winRate: totalWinRate / teamCount,
        rank: totalRank / teamCount,
        matchScore: totalMatchScore / teamCount,
        teleopScore: totalTeleopScore / teamCount,
        autoScore: totalAutoScore / teamCount,
        endgameScore: totalEndgameScore / teamCount,
        sdMatch: sdMatchScore / teamCount
      };
      teamData.innerHTML = `
    <h2>Alliance Data</h2>
    <div class="composite-score">${aggregatedData.compositeScore.toFixed(2)}</div>
    
    <div class="alliance-details">
      <p><strong>Teams:</strong> ${teamNames}</p>
      
      <p><strong>Est. Win-Loss Ratio:</strong> ${averages.winRate.toFixed(4)}</p>
      
      <p><strong>Est. Average Match Score:</strong> 
         ${averages.matchScore.toFixed(2)} Â± ${averages.sdMatch.toFixed(2)}</p>
      
      <p><strong>Est. Average Teleop Score:</strong> 
         ${averages.teleopScore.toFixed(2)}</p>
      
      <p><strong>Est. Average Auto Score:</strong> 
         ${averages.autoScore.toFixed(2)}</p>
      
      <p><strong>Est. Average Endgame Score:</strong> 
         ${averages.endgameScore.toFixed(2)}</p>
    </div>
  `;
      animateCircle(aggregatedData.compositeScore);
    }

    function animateCircle(performance) {
      const circle = document.querySelector('.circle');
      if (!circle) return;
      circle.style.animation = 'none';
      circle.offsetHeight;
      const color = getColorForPerformance(performance);
      circle.style.stroke = color;
      circle.style.animation = 'drawCircle 1s ease forwards';
    }
    const debouncedGetTeamData = debounce(handleTeamInput, 300);
    document.addEventListener('DOMContentLoaded', () => {
      const teamNumbersInput = document.getElementById('teamNumbers');
      teamNumbersInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          debouncedGetTeamData();
        }
      });
    });

    function toggleTeamData() {
      var teamData = document.querySelector('.statistic-container');
      teamData.style.display = teamData.style.display === 'none' ? 'block' : 'none';
    }

    function getColorForPerformance(performance) {
      var hue = performance * 120;
      var color;
      if (performance <= 0.5) {
        color = "hsl(" + hue + ",100%,50%)";
      } else {
        color = "hsl(" + hue + ",100%,50%)";
      }
      return color;
    }

    function displayAllianceIndicators() {
      var teamDataElement = document.getElementById('team-data');
      var teamDataHTML = '';
      teamDataHTML += '<span class="red"> ðŸŸ¥ Red Alliance </span>';
      teamDataHTML += '<span class="black"> vs </span>';
      teamDataHTML += '<span class="blue"> Blue Alliance ðŸŸ¦ </span>';
      teamDataElement.innerHTML = teamDataHTML;
    }

    function removeColoring() {
      var coloredNumbers = document.querySelectorAll('.red, .blue');
      coloredNumbers.forEach(number => {
        number.classList.remove('red', 'blue');
      });
    }

    function fetchAndProcessTeamData(teamNumbersInput) {
      var [group1, group2] = teamNumbersInput.split('-').map(g => g.trim());
      var teamNumbers1 = group1.split(',').map(num => num.trim());
      var teamNumbers2 = group2.split(',').map(num => num.trim());
      Promise.all([...teamNumbers1, ...teamNumbers2].map(teamNumber => {
          return fetch(`https://api.statbotics.io/v3/team_year/${teamNumber}/${new Date().getFullYear()}`)
            .then(response => {
              if (!response.ok) {
                throw new Error('Failed to fetch team data. Status: ' + response.status);
              }
              return response.json();
            });
        }))
        .then(teamDataArray => {
          var alliance1Data = teamDataArray.slice(0, 3);
          var alliance2Data = teamDataArray.slice(3, 6);
          var alliance1Scores = calculateAllianceScores(alliance1Data);
          var alliance2Scores = calculateAllianceScores(alliance2Data);
          displayMatchSimulation(alliance1Scores, alliance2Scores, alliance1Data, alliance2Data);
        })
        .catch(error => {
          console.error('Error fetching or processing team data:', error);
        });
    }

    function calculateAllianceScores(allianceData) {
      return {
        auto: allianceData.reduce((sum, data) => sum + data.epa.breakdown.auto_points, 0),
        teleop: allianceData.reduce((sum, data) => sum + data.epa.breakdown.teleop_points, 0),
        endgame: allianceData.reduce((sum, data) => sum + data.epa.breakdown.endgame_points, 0),
        sdAuto: Math.sqrt(allianceData.reduce((sum, data) => {
          const sd = data.epa.total_points.sd * (data.epa.breakdown.auto_points / data.epa.breakdown.total_points);
          return sum + Math.pow(sd, 2);
        }, 0)),
        sdTeleop: Math.sqrt(allianceData.reduce((sum, data) => {
          const sd = data.epa.total_points.sd * (data.epa.breakdown.teleop_points / data.epa.breakdown.total_points);
          return sum + Math.pow(sd, 2);
        }, 0)),
        sdEndgame: Math.sqrt(allianceData.reduce((sum, data) => {
          const sd = data.epa.total_points.sd * (data.epa.breakdown.endgame_points / data.epa.breakdown.total_points);
          return sum + Math.pow(sd, 2);
        }, 0))
      };
    }

    function displayMatchSimulation(alliance1Scores, alliance2Scores, alliance1Data, alliance2Data) {
      var teamData = document.getElementById('team-data');
      var totalScore1 = alliance1Scores.auto + alliance1Scores.teleop + alliance1Scores.endgame;
      var totalScore2 = alliance2Scores.auto + alliance2Scores.teleop + alliance2Scores.endgame;
      var totalSD1 = Math.sqrt(
        Math.pow(alliance1Scores.sdAuto, 2) +
        Math.pow(alliance1Scores.sdTeleop, 2) +
        Math.pow(alliance1Scores.sdEndgame, 2)
      );
      var totalSD2 = Math.sqrt(
        Math.pow(alliance2Scores.sdAuto, 2) +
        Math.pow(alliance2Scores.sdTeleop, 2) +
        Math.pow(alliance2Scores.sdEndgame, 2)
      );
      var pointDiff = Math.abs(totalScore1 - totalScore2);
      var favoredAlliance = totalScore1 > totalScore2 ? 'Red' : 'Blue';
      var pointDiffColor = totalScore1 > totalScore2 ? '#F91A48' : '#087cfc';
      var pointDiffHTML = `
    <h2>Predicted Score:</h2>
    <div class="combined-scores">
      <table>
        <tr>
          <th>Alliance</th>
          <th>Predicted Score</th>
          <th>Point Differential</th>
        </tr>
        <tr>
          <td style="color: #F91A48">Red Alliance</td>
          <td>${totalScore1.toFixed(2)} Â± ${totalSD1.toFixed(2)}</td>
          <td rowspan="2" style="color: ${pointDiffColor}">
            <b>${pointDiff.toFixed(2)}</b><br>
            <small>(${favoredAlliance} favored)</small>
          </td>
        </tr>
        <tr>
          <td style="color: #087cfc">Blue Alliance</td>
          <td>${totalScore2.toFixed(2)} Â± ${totalSD2.toFixed(2)}</td>
        </tr>
      </table>
    </div>`;
      teamData.innerHTML = pointDiffHTML;
      displayCombinedScores(alliance1Data, alliance2Data);
    }

    function displaySummedPoints(totalPoints1, totalPoints2, teamDataArray) {
      var teamData = document.getElementById('team-data');
      var p1 = totalPoints1.toFixed(2);
      var p2 = totalPoints2.toFixed(2);
      var pd1 = totalPoints1.toFixed(2) - totalPoints2.toFixed(2);
      var pd2 = totalPoints2.toFixed(2) - totalPoints1.toFixed(2);
      var sd1 = Math.sqrt(Math.pow(teamDataArray[0].epa.breakdown.auto_points.sd, 2) + Math.pow(teamDataArray[1].epa.breakdown.teleop_points.sd, 2) + Math.pow(teamDataArray[2].epa.breakdown.endgame_points.sd, 2));
      var sd2 = Math.sqrt(Math.pow(teamDataArray[3].epa.breakdown.auto_points.sd, 2) + Math.pow(teamDataArray[4].epa.breakdown.teleop_points.sd, 2) + Math.pow(teamDataArray[5].epa.breakdown.endgame_points.sd, 2));
      teamData.innerHTML = '<h2>Point Diff:</h2>';
      var table = document.createElement('table');
      if (pd1 > 0) {
        var row1 = table.insertRow();
        var cell1_1 = row1.insertCell(0);
        var cell1_2 = row1.insertCell(1);
        cell1_1.textContent = 'Point Diff (A1):';
        cell1_2.id = 'pointDiffCellA1';
        cell1_2.className = 'point-diff-cell';
        cell1_2.innerHTML = `<span style="color: #F91A48;"><b>${pd1.toFixed(2)} Â± ${sd1.toFixed(2)}</b></span>`;
        cell1_2.style.cursor = 'pointer';
        cell1_2.addEventListener('click', function() {
          console.log('Clicked Point Diff (A1)');
          toggleCombinedScores(teamDataArray.slice(0, 3), teamDataArray.slice(3, 6));
        });
      }
      if (pd2 > 0) {
        var row2 = table.insertRow();
        var cell2_1 = row2.insertCell(0);
        var cell2_2 = row2.insertCell(1);
        cell2_1.textContent = 'Point Diff (A2):';
        cell2_2.id = 'pointDiffCellA2';
        cell2_2.className = 'point-diff-cell';
        cell2_2.innerHTML = `<span style="color: #087cfc;"><b>${pd2.toFixed(2)} Â± ${sd2.toFixed(2)}</b></span>`;
        cell2_2.style.cursor = 'pointer';
        cell2_2.addEventListener('click', function() {
          console.log('Clicked Point Diff (A2)');
          toggleCombinedScores(teamDataArray.slice(0, 3), teamDataArray.slice(3, 6));
        });
      }
      teamData.appendChild(table);
    }

    function toggleCombinedScores(alliance1, alliance2) {
      console.log('Toggling Combined Scores');
      var combinedScores = document.getElementById('combined-scores');
      if (combinedScores.style.display === 'none') {
        displayCombinedScores(alliance1, alliance2);
        combinedScores.style.display = 'block';
      } else {
        combinedScores.style.display = 'none';
      }
    }

    function displayCombinedScores(alliance1, alliance2) {
      var teamData = document.getElementById('team-data');
      var combinedScores = document.getElementById('combined-scores');
      if (combinedScores) {
        combinedScores.remove();
      }
      combinedScores = document.createElement('div');
      combinedScores.id = 'combined-scores';
      combinedScores.innerHTML = '<h2>Match Breakdown</h2>';
      var totalPointsAuto1 = alliance1.reduce((sum, data) => sum + data.epa.breakdown.auto_points, 0);
      var totalPointsTeleop1 = alliance1.reduce((sum, data) => sum + data.epa.breakdown.teleop_points, 0);
      var totalPointsEndgame1 = alliance1.reduce((sum, data) => sum + data.epa.breakdown.endgame_points, 0);
      var totalPointsAuto2 = alliance2.reduce((sum, data) => sum + data.epa.breakdown.auto_points, 0);
      var totalPointsTeleop2 = alliance2.reduce((sum, data) => sum + data.epa.breakdown.teleop_points, 0);
      var totalPointsEndgame2 = alliance2.reduce((sum, data) => sum + data.epa.breakdown.endgame_points, 0);
      var totalSDAuto1 = Math.sqrt(alliance1.reduce((sum, data) => {
        const sd = data.epa.total_points.sd * (data.epa.breakdown.auto_points / data.epa.breakdown.total_points);
        return sum + Math.pow(sd, 2);
      }, 0));
      var totalSDTeleop1 = Math.sqrt(alliance1.reduce((sum, data) => {
        const sd = data.epa.total_points.sd * (data.epa.breakdown.teleop_points / data.epa.breakdown.total_points);
        return sum + Math.pow(sd, 2);
      }, 0));
      var totalSDEndgame1 = Math.sqrt(alliance1.reduce((sum, data) => {
        const sd = data.epa.total_points.sd * (data.epa.breakdown.endgame_points / data.epa.breakdown.total_points);
        return sum + Math.pow(sd, 2);
      }, 0));
      var totalSDAuto2 = Math.sqrt(alliance2.reduce((sum, data) => {
        const sd = data.epa.total_points.sd * (data.epa.breakdown.auto_points / data.epa.breakdown.total_points);
        return sum + Math.pow(sd, 2);
      }, 0));
      var totalSDTeleop2 = Math.sqrt(alliance2.reduce((sum, data) => {
        const sd = data.epa.total_points.sd * (data.epa.breakdown.teleop_points / data.epa.breakdown.total_points);
        return sum + Math.pow(sd, 2);
      }, 0));
      var totalSDEndgame2 = Math.sqrt(alliance2.reduce((sum, data) => {
        const sd = data.epa.total_points.sd * (data.epa.breakdown.endgame_points / data.epa.breakdown.total_points);
        return sum + Math.pow(sd, 2);
      }, 0));
      var table = document.createElement('table');
      table.innerHTML = `
    <tr>
      <th>Alliance</th>
      <th>Auto (Â± SD)</th>
      <th>Teleop (Â± SD)</th>
      <th>Endgame (Â± SD)</th>
    </tr>
    <tr>
      <td>Red Alliance:</td>
      <td><b>${totalPointsAuto1.toFixed(2)}</b> Â± ${totalSDAuto1.toFixed(2)}</td>
      <td><b>${totalPointsTeleop1.toFixed(2)}</b> Â± ${totalSDTeleop1.toFixed(2)}</td>
      <td><b>${totalPointsEndgame1.toFixed(2)}</b> Â± ${totalSDEndgame1.toFixed(2)}</td>
    </tr>
    <tr>
      <td>Blue Alliance:</td>
      <td><b>${totalPointsAuto2.toFixed(2)}</b> Â± ${totalSDAuto2.toFixed(2)}</td>
      <td><b>${totalPointsTeleop2.toFixed(2)}</b> Â± ${totalSDTeleop2.toFixed(2)}</td>
      <td><b>${totalPointsEndgame2.toFixed(2)}</b> Â± ${totalSDEndgame2.toFixed(2)}</td>
    </tr>
  `;
      combinedScores.appendChild(table);
      var datasets = [{
        label: 'Red Alliance',
        borderColor: 'rgba(249, 26, 72, 1)',
        backgroundColor: 'rgba(249, 26, 72, 0.1)',
        data: [totalPointsAuto1, totalPointsTeleop1, totalPointsEndgame1],
        fill: true
      }, {
        label: 'Blue Alliance',
        borderColor: 'rgba(8,124,252, 1)',
        backgroundColor: 'rgba(8,124,252, 0.1)',
        data: [totalPointsAuto2, totalPointsTeleop2, totalPointsEndgame2],
        fill: true
      }];
      var chartContainer = document.createElement('div');
      chartContainer.classList.add('chart-container');
      chartContainer.style.marginTop = '20px';
      chartContainer.style.height = '300px';
      var combinedChartCanvas = document.createElement('canvas');
      combinedChartCanvas.id = 'combined-chart';
      chartContainer.appendChild(combinedChartCanvas);
      combinedScores.appendChild(chartContainer);
      if (window.combinedChart) {
        window.combinedChart.destroy();
      }
      window.combinedChart = new Chart(combinedChartCanvas, {
        type: 'line',
        data: {
          labels: ['Auto', 'Teleop', 'Endgame'],
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Points'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Game Phase'
              }
            }
          },
          plugins: {
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed.y !== null) {
                    label += context.parsed.y.toFixed(2) + ' points';
                  }
                  return label;
                }
              }
            },
            legend: {
              position: 'top',
            }
          }
        }
      });
      teamData.appendChild(combinedScores);
    }

    function toggleCombinedScores(alliance1, alliance2) {
      var combinedScores = document.getElementById('combined-scores');
      if (!combinedScores) {
        displayCombinedScores(alliance1, alliance2);
      } else {
        combinedScores.remove();
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
    }

    function getColorBrightness(color) {
      const hex = color.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      return (r * 0.299 + g * 0.587 + b * 0.114);
    }
  </script>
</body>

</html>
